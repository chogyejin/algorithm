# 다이나믹 프로그래밍(DP)

- 배경
  - 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘 작성이 필요
- DP 사용 조건
  1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
  2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일
- 종류
  - 탑다운(하향식) : 재귀함수 이용 큰 문제 해결시 작은 문제 호출, 메모이제이션
  - 바텀업(상향식) : 반복문 이용 아래에서 위로 해결, 재귀함수는 스택 크기 제한이 있을 수 있어서 가능하면 바텀업 추천
- 대표적으로 피보나치 수열

  - n번째 피보나치 수 = (n-1)번째 피보나치 수 + (n-2)번째 피보나치 수
  - 1번째, 2번째 피보나치 수는 1

  ```
  def fibo(x):
    if x == 1 or x == 2:
      return 1
    return fibo(x - 1) + fibo(x - 2)

  print(fibo(4)) # 3
  ```

  - 문제점은 중복 되는 계산을 반복해서 수행하여 n이 커질수록 수행 시간이 급격하게 늘어남(시간 복잡도 O(2^N))
  - 메모이제이션(Memoization) 기법 활용하여 해결하기
    - 한 번 계산한 정답을 리스트에 저장

  ```
  d = [0] * 100 # 메모이제이션 리스트 초기화, DP 테이블

  def fibo(x):
    # 종료 조건
    if x == 1 or x == 2:
      return 1

    # 이미 계산한 적 있으면 그대로 return
    if d[x] != 0:
      return d[x]

    # 계산한 적 없다면 피보나치 값 저장하여 리턴
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

  print(fibo(99))
  ```

  - 메모이제이션 이용한 피보나치는 시간 복잡도 O(N)
